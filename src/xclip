/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   events.c                                           :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: mprunty <mprunty@student.42london.com>     +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2024/12/23 21:43:57 by mprunty           #+#    #+#             */
/*   Updated: 2024/12/23 21:50:02 by mprunty          ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "../include/fractol.h"
#include "X11/X.h"
/**
 * @brief closes out the session, destroy all mlx connections and free mem
 *
 * @param f t_fractal to destroy
 */
int	close_handler(t_fractal *f)
{
	mlx_destroy_image(f->mlx_connection, f->img.img);
	clean_fractal(f, -1, "");
	exit(EXIT_SUCCESS);
}

/**
 * @brief function move the screen
 *
 * @param f fractal object
 * @param axis axis i.e 'x' or 'y'
 * @param delta amount to move by
 */
void	move(t_fractal *f, int axis, double delta)
{
	if (axis == 'x')
		f->shift.x += (delta * f->zoom);
	else if (axis == 'y')
		f->shift.y += (delta * f->zoom);
	render_f(f);
}

/**
 * @brief function to in/decrement f.iterations
 *
 * @param f t_fractal object 
 * @param delta  int amount to inc/dec f.iterations by
 */
void	inc_iters(t_fractal *f, double delta)
{
	f->iterations += delta;
	render_f(f);
}

/**
 * @brief handles key inputs
 *
 * @param keysym int representation of key pressed
 * @param f t_fractal
 * @return 0
 */
int	key_handler(int keysym, t_fractal *f)
{
	ft_printf("\t%i\t", keysym);
	if (keysym == KEY_ESC)
		close_handler(f);
	if (keysym == KEY_LEFT)
		move(f, 'x', 0.5);
	else if (keysym == KEY_RIGHT)
		move(f, 'x', -0.5);
	else if (keysym == KEY_UP)
		move(f, 'y', -0.5);
	else if (keysym == KEY_DOWN)
		move(f, 'y', 0.5);
	else if (keysym == KEY_PLUS)
		inc_iters(f, 10);
	else if (keysym == KEY_MINUS)
		inc_iters(f, -10);
	return (0);
}

/**
 * @brief function to handle mouse inputs 
 *
 * @param button 
 * @param x 
 * @param y 
 * @param f 
 * @return 
 */
int	mouse_handler(int button, int x, int y, t_fractal *f)
{
	if (button == Button5)
		f->zoom *= 0.95;
	else if (button == Button4)
		f->zoom *= 1.05;
	render_f(f);
	(void)x;
	(void)y;
	return (0);
}

/*
 * TRACK the mouse
 * to change julia dynamically
 * int (*f)(int x, int y, void *param)
 */
/*
   int	julia_track(int x, int y, t_fractal *fractal)
   {
   if (!ft_strncmp(fractal->name, "julia", 5))
   {
   fractal->julia_x = (map(x, -2, +2, 0, WIDTH) * fractal->zoom) +
   fractal->shift_x; fractal->julia_y = (map(y, +2, -2, 0, HEIGHT) * fractal->zoom)
   + fractal->shift_y; fractal_render(fractal);
   }
   return 0;
   }
   */
#include "../include/fractol.h"

int linear_interpolation(double t, t_fractal *fractal)
{
	int	red;
	int	green;
	int	blue;

	(void)fractal;
	if (t < 0)
		t = 0;
	if (t > 1)
		t = 1;
	red = ((WHITE >> 16) & 0xFF) * t;
	green = ((WHITE >> 8) & 0xFF) * t;
	blue = (WHITE & 0xFF) * t;
	return ((red << 16) | (green << 8) | blue);
}

/**
 * @brief Fonction pour déterminer la couleur d'un pixel à l'extérieur
 *	de l'ensemble de Mandelbrot.
 *
 * @param z Le point z après l'itération finale.
 * @param der La dérivée de z après l'itération finale.
 * @return int Couleur à appliquer au format 0x00RRGGBB.
 */
int	normal_color(t_complex z, t_complex der, t_fractal *fractal)
{
	t_complex	u;
	t_complex	v;
	double		t;
	double		angle;

	angle = 2.0 * 1.5 * M_PI / 360.0;
	ft_complex_exp(angle, &v);
	u = ft_complex_divide(z, der);
	u.x /= ft_complex_abs(u);
	u.y /= ft_complex_abs(u);
	t = ft_complex_dot(&u, &v) + 2; // + fractal->color_h;
	t = t / (1 + 2);                // fractal->color_h);
	return (linear_interpolation(t, fractal));
}

int	is_in_mandelbrot_set(double x, double y)
{
	double	p;
	double	q;

	p = sqrt((x - 0.25) * (x - 0.25) + y * y);
	if (x < p - 2 * p * p + 0.25)
		return (1);
	q = (x + 1) * (x + 1) + y * y;
	if (q <= 1.0 / 16.0)
		return (1);
	return (0);
}
void	my_mlx_pixel_put(t_data *data, int x, int y, int color)
{
	int	dst;

	//printf("%f", data);
	dst = (y * data->line_length) + (x * (data->bits_per_pixel / 8));
	*(unsigned *)(data->pxl_addr + dst) = color;
	return;
}


/**
 * @brief y = y1 + ((x-x1) * (y2-y1) / (x2-x1))
 *
 * @param pixel 
 * @param f 
 * @return 
 */
t_complex	map_complex(t_complex *pixel, t_fractal *f)
{
	t_complex	map_complex;
	/*
	   map_complex.x = ((scale_linear(pixel.x, f.minmax, f.screensize) * f.zoom)
	   + f.shift.x) ; map_complex.y = ((scale_linear(pixel.y, f.minmax,
	   f.screensize) * f.zoom) + f.shift.y) ; map_complex.x = scale_linear(double
	   n, t_complex new_minmax, t_complex old_minmax)
	   */
	/*
	*/
	map_complex.x = scale_linear(pixel->x, f->minmax, f->screensize) 
		* f->zoom
		+ f->shift.x;
	map_complex.y = scale_linear(pixel->y, f->minmax, f->screensize)
		* f->zoom
		+ f->shift.y;
	/*map_complex.x = f->minmax.y +
		(pixel->x / WIDTH * (f->minmax.x - f->minmax.y) *
	//(((pixel->x * f->minmax.x - f->minmax.y) / WIDTH + f->minmax.y) *
		 f->zoom +
		 f->shift.x);
	map_complex.y =
		(pixel->y / HEIGHT * (f->minmax.x - f->minmax.y) *
		//(((pixel->y * f->minmax.x - f->minmax.y) / HEIGHT + f->minmax.y) *
		f->zoom +
		f->shift.y);
*/
	return (map_complex);
}

void	init_constant(t_fractal *f, t_complex *c, t_complex *z)
{
	if (*f->name != 'j')
	{
		c->x = z->x;
		c->y = z->y;
	}
}

void	place_pixel(t_fractal *f, t_complex *pixel)
{
	t_complex	z;
	t_complex	zprime;
	int			i;
//	t_complex	c;
	//  z.x = ((scale_linear(pixel.x, f.minmax, f.screensize) * f.zoom) +
	//  f.shift.x) ; z.y = ((scale_linear(pixel.y, f.minmax, f.screensize) *
	//  f.zoom) + f.shift.y) ;
	zprime = (t_complex){1.0, 0.0};
	z = map_complex(pixel, f);
	f->c = z; //(t_complex){};
	i = -1;
	if (is_in_mandelbrot_set(z.x, z.y))  //&& *f.name =='m'
	{
		//	printf("\nz: %f %f,  c: %f %f,  pix: %f %f", z.y, z.x, c.y, c.x, pixel->x, pixel->y);
		return (my_mlx_pixel_put(&f->img, pixel->x, pixel->y, BLACK));
	}
	while (i++ < f->iterations)
	{
		if (pow(z.y, 2) + pow(z.x, 2) > f->escape)
		{
			return	my_mlx_pixel_put(&f->img, pixel->x, pixel->y, normal_color(z, zprime, f));
		}
		zprime = (t_complex){2 * z.x * zprime.x - 2 * z.y * zprime.y,
			2 * z.x * zprime.y + 2 * z.y * zprime.x};
		z = ft_complex_sum(ft_complex_sqrd(z), f->c); // z^2 +c
	}
	my_mlx_pixel_put(&f->img, pixel->x, pixel->y, LIME_SHOCK);
}

void	render_f(t_fractal *f)
{
	t_complex	pixel;
	//	int x;
	//	int y;
	(pixel.y) = -1.0;
	while (++pixel.y < HEIGHT)
	{
		ft_putnbr_fd(pixel.y, 1);
		ft_putchar_fd(' ', 1);
		//ft_putchar_fd('', 1);
		pixel.x = -1.0;
		while (++pixel.x < WIDTH)
		{
			//ft_putnbr_fd(pixel.x, 1);
			place_pixel(f, &pixel);
		}
	}
	mlx_put_image_to_window(f->mlx_connection, f->mlx_window, f->img.img, 0, 0);
	mlx_string_put(f->mlx_connection, f->mlx_window, 20, 30, 0XFFFFFF - WHITE,
		"Help: h");
	return ;
}
#include "fractol.h"


/**
 * @brief initialise starting fractal
 *
 * @param f 
 * @return 
 */
void    init_f(t_fractal *f)
{

    f->mlx_connection = mlx_init();
    if (!(f->mlx_connection))
        return ((void)error_func(2, "Could not establish mlx_connection"));
    f->mlx_window = mlx_new_window(f->mlx_connection, HEIGHT, WIDTH, f->name);
    if (!(f->mlx_window))
        return clean_fractal(f, 3,"Could not establish mlx_new_window" );
    f->img.img = mlx_new_image(f->mlx_connection,  HEIGHT, WIDTH);
    if (!(f->img.img))
        return clean_fractal(f, 4, "Could not establish mlx_new_image");
    f->img.pxl_addr = mlx_get_data_addr(f->img.img,
            &f->img.bits_per_pixel,
            &f->img.line_length,
            &f->img.endian);

    init_events(f);
    return ;

}
/**
 * @brief 
 *
 * @param f 
 */
void    init_events(t_fractal *f){
    mlx_hook(f->mlx_window,
			KeyPress,
			KeyPressMask,
			key_handler,
			f);
	mlx_hook(f->mlx_window,
			ButtonPress,
			ButtonPressMask,
			mouse_handler,
			f);
	mlx_hook(f->mlx_window,
			DestroyNotify,
			StructureNotifyMask,
			close_handler,
			f);
/*	mlx_hook(f->mlx_window,
			MotionNotify,
			PointerMotionMask,
			julia_track,
			f);
*/
}
/**
 * @brief 
 *
 * @param f 
 */
void    init_values(t_fractal *f, char **av){
	f->zoom = 0.5;
	f->iterations = 5;
	f->escape = 4;
    f->minmax = (t_complex){2, -2};
	f->shift = (t_complex){0,0};//f->minmax.x, f->minmax.y};
	f->screensize = (t_complex){800, 0};
    if (*(f->name) == 'j')
    {
        f->c.x = ft_atof(*av++);
        f->c.y = ft_atof(*av);
    }
    else
    {
        f->c.x = 0; 
        f->c.y = 0;
    }
    return ;
}
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   main.c                                             :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: mprunty <mprunty@student.42london.com>     +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2024/12/23 22:08:07 by mprunty           #+#    #+#             */
/*   Updated: 2024/12/24 14:28:04 by mprunty          ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */
#include "../include/fractol.h"

/**
 * @brief function to handle errors
 *
 * @param i error number
 * @param info info to return about error
 * @return an int 0  
 */
int	error_func(int i, char *info)
{
	if (i == 0)
		return (0);
	ft_putendl_fd("Error", 2);
	if (i == 1)
		ft_printf("%s", "incorrect input:");
	else if (i == 2)
		ft_printf("%s", "malloc failed");
	else if (i == 3)
		ft_printf("%s", "mlx error:");
	else if (i == 4)
		ft_printf("%s", "mlx_display error");
	else if (i == 5)
		ft_printf("%s", "");
	else if (i == 6)
		ft_printf("%s", "turk sort failed");
	ft_printf("%s", info);
	return (0);
}

int	create_trgb(int t, int r, int g, int b)
{
	return (t << 24 | r << 16 | g << 8 | b);
}

/*
 *  x^2 + y^2 +  2xyi
 *  |       \   \   \
 *    Real      imAGINERY
 */
int draw_line(void *mlx,  int beginX, int beginY, int endX, int endY, int color)
{
	double deltaX = endX - beginX;
	double deltaY = endY - beginY;
	int pixels = ft_sqrtbs((deltaX * deltaX) + (deltaY * deltaY));

	double pixelX = beginX;
	double pixelY = beginY;
	while (pixels)
	{
		my_mlx_pixel_put(mlx,  pixelX, pixelY, color);
		pixelX += deltaX / pixels;
		pixelY += deltaY / pixels;
		--pixels;
	}
	return (0);
}

/**
 * @brief cleans up the fractal: destroys mlx, frees mem, and relays any error
 * 
 * @param f main t_fractal object
 * @param n_error error number set to -1 if no error 
 * @param info further info on error, leave blank if none
 */
void	clean_fractal(t_fractal *f, int n_error, char *info)
{
	if (n_error >= 0)
		error_func(n_error, info);
	if ((f->mlx_window))
		mlx_destroy_window(f->mlx_connection, f->mlx_window);
	if ((f->img.img))
		mlx_destroy_display(f->mlx_connection);
	free(f->mlx_connection);
	return ;
}

/**
 * @brief converts a string to float 
 *
 * @param nptr string to convert
 * @return a double of the string converted
 */
double	ft_atof(const char *nptr)
{
	int		neg;
	int		decimal;
	double	res;

	res = 0;
	neg = 1;
	if (nptr)
	{
		decimal = 0;
		while (ft_isblank(*nptr) || (nptr[0] == '-' || nptr[0] == '+'))
			if (*nptr++ == '-')
				neg *= -1;
		while (ft_isdigit(*nptr))
		{
			if (!decimal)
				res = res * 10 + (*nptr - 48);
			else
				res += ft_pow(10, -decimal++) * (*nptr - 48);
			if (*++nptr == '.' && !decimal++)
				nptr++;
		}
	}
	return (res * neg);
}

/**
 * @brief function to check if a string value is a float
 *
 * @param str string to check
 * @param dec boolean switch to deal with a single decimal point 
 * @return 1 if isnum else 0
 */
int	ft_isnumf(char *str, int dec)
{
	if (*str == '\0')
		return (1);
	if (dec && *str == '.')
		return (ft_isnumf(++str, 0) * 1);
	if (ft_isdigit(*str))
		return (ft_isnumf(++str, dec) * 1);
	return (0);
}

int	main(int ac, char **av)
{
	t_fractal	f;

	if (!(ac >= 2) || ! ((*(av++)) && (**av == 'j' || **av == 'm')))
		return (error_func(1, "enter either 'm' or 'j x y' "));
	f.name = *av++;
	if ((*f.name == 'j') && (!ft_isnumf(*av, 1) || !ft_isnumf(*(av + 1), 1)))
		return (error_func(1,
				"julia set must be initialised with  x y in the form 'j x y'"));
	init_values(&f, av);
	init_f(&f);
//	printf("\n%f %f",f.c.x,f.c.y);
	render_f(&f);
	mlx_loop(f.mlx_connection);
	clean_fractal(&f, -1, "");
	/*
	 * double i = 0;
	 * while (i++ < 800)
	 printf("\n%f", scale_linear(i, -2, 2));
	 */
	printf("\n%f",pow(3,2));
	printf("\n%f",pow(7, 10));
	printf("\n%f",pow(-5, 3));
	printf("\n%f",ft_sqrtbs(7));
	printf("\n%f",ft_sqrtbs(9));
	printf("\n%f",ft_sqrtbs(2));
	printf("\n%f",pow(10, -3));
	printf("\n%f",pow(-5, -6));
	printf("\n%f %f",f.c.x,f.c.y);
	printf("\n%f %f",ft_atof("3.14"),ft_atof("-3.14"));
	printf("\n%f %f",ft_atof("++ 0.14"),ft_atof("---3.14"));
	printf("\n%f %f",ft_atof("++ 0.8712364876114"),ft_atof("---3.12987398114"));
	//printf("%f",ft_sqrt(-3));
	return (0);
}

/* f(z) = z^2 + c
 * z = 0, c = 1
 * = f(0) = 0^2 + 1

*/

#include "../include/fractol.h"

double	ft_complex_abs(t_complex complex)
{
	return (ft_sqrtbs(complex.x * complex.x + complex.y * complex.y));
}

double	ft_complex_dot(t_complex *a, t_complex *b)
{
	return (a->x * b->x + a->y * b->y);
}

void	ft_complex_exp(double angle, t_complex *result)
{
	double	magnitude;

	magnitude = exp(angle);
	result->x = magnitude * cos(angle);
	result->y = magnitude * sin(angle);
}

/**
 * @brief Calcule le conjugué d'un nombre complexe.
 *
 * @param a Le nombre complexe.
 * @return t_complex Le conjugué du nombre complexe.
 */
t_complex	ft_complex_conjugate(t_complex a)
{
	t_complex	result;

	result.x = a.x;
	result.y = -a.y;
	return (result);
}

/**
 * @brief Divise deux nombres complexes.
 *
 * @param numerator Le numérateur (z).
 * @param denominator Le dénominateur (w).
 * @return t_complex Le résultat de la division.
 */
t_complex	ft_complex_divide(t_complex numerator, t_complex denominator)
{
	t_complex	result;
	t_complex	denom_conjugate;
	t_complex	num_mult;
	double		denom_mult;

	denom_conjugate = ft_complex_conjugate(denominator);
	num_mult = (t_complex){numerator.x * denom_conjugate.x - numerator.y
		* denom_conjugate.y, numerator.x * denom_conjugate.y + numerator.y
		* denom_conjugate.x};
	denom_mult = denominator.x * denominator.x + denominator.y * denominator.y;
	result.x = num_mult.x / denom_mult;
	result.y = num_mult.y / denom_mult;
	return (result);
}
#include "../include/fractol.h"

double  ft_min(double x, double y)
{
    if (x > y)
        return (y);
    return (x);
}
double  ft_max(double x, double y)
{
    if (x < y)
        return (y);
    return (x);
}
double ft_pow(double d, int pow)
{
    if (pow > 0)
        return (d * ft_pow(d, --pow));
    if (pow < 0)
        return (1/d * ( ft_pow(d, ++pow)));
    return (1);
}
double  ft_sqrtbs(double n)
{
  // Max and min are used to take into account numbers less than 1
  double lo = ft_min(1, n), hi = ft_max(1, n), mid;

  // Update the bounds to be off the target by a factor of 10
  while(100 * lo * lo < n) lo *= 10;
  while(0.01 * hi * hi > n) hi *= 0.1;

  for(int i = 0 ; i < 100 ; i++){
    mid = (lo+hi)/2;
    if(mid*mid == n) return mid;
    if(mid*mid > n) hi = mid;
    else lo = mid;
  }
  return mid;
}
/**
 * @brief y = y1 + ((x-x1) * (y2-y1) / (x2-x1))
 *
 * @param n 
 * @param p1 
 * @param p2 
 * @return 
 */
double  scale_linear(double n, t_complex p1, t_complex p2)
{
    return (p1.y + ((n -p1.x) * (p2.y - p1.y)/ p2.x - p1.x));
}

/**
 * @brief (x + yi)^2 = (x^2 - y^2) + 2xyi
 *
 * @param z 
 * @return 
 */
t_complex   ft_complex_sqrd(t_complex z)
{
    t_complex   c;
   
    c.x = ft_pow(z.x, 2) - ft_pow(z.y, 2);
    c.y =  2 * (z.x) + (z.y); 
    return (c);
}

t_complex   ft_complex_sum(t_complex z1, t_complex z2)
{
    t_complex   c;
    c.x = (z1.x) + (z2.x); 
    c.y = (z1.y) + (z2.y); 
    return (c);
}
